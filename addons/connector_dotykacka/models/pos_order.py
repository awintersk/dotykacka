"""Module for Dotykacka PoS Order extension."""
__version__ = "1.1"

import logging

from odoo import _, api, fields, models
from odoo.exceptions import ValidationError, UserError

_logger = logging.getLogger(__name__)

LOG_ORIGIN = __name__


class PosOrder(models.Model):
    """Extension of pos.order to communicate with dotykacka."""

    _inherit = 'pos.order'

    _payment_method = None

    dotykacka_order_id = fields.Many2one('dotykacka.order', string='Dotykacka Order', copy=False)
    sent_to_terminal = fields.Boolean(default=False, copy=False)
    printed = fields.Boolean(default=False, copy=False)
    parent_id = fields.Many2one(
        'pos.order', string='Parent Order', ondelete='set null', index=True, copy=False
    )
    return_ids = fields.One2many('pos.order', 'parent_id', copy=False)
    returns_count = fields.Integer(string='Returns', compute='_compute_returns_count', copy=False)

    @property
    def payment_method(self):
        """Payment Method Property."""
        if not self._payment_method:
            uniques = set(self.payment_ids.mapped('payment_method_id'))
            count = len(uniques)
            if count == 0:
                self._payment_method = self.env['pos.payment.method']
            elif count == 1:
                (self._payment_method,) = uniques
            else:
                self._payment_method = uniques
        return self._payment_method

    @api.depends('return_ids')
    def _compute_returns_count(self):
        for order in self:
            order.returns_count = len(order.return_ids)

    # pylint:disable=W0212,W0201
    def _compute_amount(self):
        currency = self.pricelist_id.currency_id
        self.amount_tax = currency.round(
            sum(self._amount_line_tax(line, self.fiscal_position_id) for line in self.lines)
        )
        amount_untaxed = currency.round(sum(line.price_subtotal for line in self.lines))
        self.amount_total = self.amount_tax + amount_untaxed

    def __check_terminal_dotykacka(self) -> bool:
        """
        Determine if order should be sent to dotykacka.

        :param pos_order: pos.order record
        :param payment_method: pos.payment.method record

        :raises ValidationError: When order cannot be processed by dotykacka
        :return: True when order should be sent to dotykacka else False
        """
        self.ensure_one()
        if not self.session_id.config_id.use_dotykacka:
            return False
        if not self.session_id.config_id.dotykacka_branch_id:
            return False

        payment_method = self.payment_method
        if not payment_method:
            return False
        if len(payment_method) == 1 and payment_method.use_payment_terminal != 'dotykacka':
            return False

        if len(payment_method) >= 2:
            raise ValidationError(
                _("Dotykacka can currently process only one payment method per order!")
            )
        if not payment_method.dotykacka_method_identifier:
            raise ValidationError(_("Payment method ID for dotykacka not found!"))
        return True

    def __prepare_new_dotykacka_data(self, order_data: dict):
        """
        Prepare order data from pos ui.

        :param order_data: dict
        :return: dict
        """
        order_name = order_data['name']
        _logger.info("Processing PoS order %s", order_name)

        def prepare_line(item_data: dict):
            product_id = self.env['product.product'].browse(int(item_data['product_id']))
            self.env['dotykacka.product.catalog'].sync_products_to_dotykacka(product_id)
            line_dict = {
                'id': product_id.dotykacka_id,
                'qty': item_data['qty'],
                'manual-price': item_data['price_unit'],
            }
            if item_data['pack_lot_ids']:
                line_dict['note'] = item_data['pack_lot_ids']
            if item_data['discount']:
                line_dict['discount-percent'] = item_data['discount']
            return line_dict

        order_lines = [prepare_line(item[2]) for item in order_data['lines']]
        return self.__prepare_dotykacka_data(order_lines, order_name)

    def __prepare_existing_dotykacka_data(self):
        """Mock the order_data generated by the pos ui using existing order."""
        _logger.info("Processing PoS order %s", self.pos_reference)

        def prepare_line(line):
            self.env['dotykacka.product.catalog'].sync_products_to_dotykacka(line.product_id)
            item_data = {
                'id': line.product_id.dotykacka_id,
                'qty': line.qty,
                'manual-price': line.price_unit,
            }
            if line.pack_lot_ids:
                item_data['note'] = line.pack_lot_ids
            if line.discount:
                item_data['discount-percent'] = line.discount
            return item_data

        order_lines = [prepare_line(line) for line in self.lines]
        return self.__prepare_dotykacka_data(order_lines, self.pos_reference)

    def __prepare_dotykacka_data(self, order_lines, order_name):
        """
        Prepare order data which will be sent to Dotykacka.

        :param order_lines: list of dict representing pos order lines
        :param order_name: str name of the order

        :return: dict with data for dotykacka
        """
        payment_method = self.payment_method
        payment_method_id = int(payment_method.dotykacka_method_identifier)
        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
        return {
            'action': 'order/create-issue-pay',
            'webhook': f"{base_url}/rest/v1/dotykacka/order/map",
            'user-id': '-1',
            'external-id': order_name,
            'items': order_lines,
            'discount-percent': 0,
            'payment-method-id': payment_method_id,
            'print-type': 'local',
        }

    def __prepare_dotykacka_request(self):
        """
        Prepare request and parameters for dotykacka.

        :return: tuple(api_manager.request, dotykacka.branch, int) request, branch_id, cloud_id
            - request: api_manager.request Record
            - branch_id: Identifier of dotykacka branch
            - cloud_id: Identifier of dotykacka cloud

        """
        request = self.env.ref('connector_dotykacka.api_request_dotykacka_pos_actions')
        cloud_id = (
            self.env['api_manager.request_parameter']
            .search(
                [
                    ('provider', '=', request.provider.id),
                    ('key', '=', 'cloud_id'),
                    ('company_id', '=', self.env.company.id),
                ]
            )
            .value
        )
        branch_id = self.session_id.config_id.dotykacka_branch_id
        return request, branch_id, cloud_id

    # pylint:disable=W0212
    def __create_dotykacka_order(self, branch_id, cloud_id):
        """
        Create dotykacka order for current pos order.

        :param branch_id: Identifier of dotykacka branch
        :param cloud_id: Identifier of dotykacka cloud

        :return: dotykacka.order record
        """
        pos_model_id = self.env['ir.model'].search([('model', '=', 'pos.order')]).id
        return self.env['dotykacka.order'].create(
            [
                {
                    'cloud_id': cloud_id,
                    'branch_id': branch_id,
                    'model_id': pos_model_id,
                    'record_id': self.id,
                    'company_id': self.env.company.id,
                    'reference': self.pos_reference,
                    'created_at': fields.Datetime.now(),
                }
            ]
        )

    # pylint:disable=W0212
    def __get_dotykacka_order(self):
        """Get dotykacka order for current pos order."""
        pos_model_id = self.env['ir.model'].search([('model', '=', 'pos.order')]).id
        dotykacka_order = self.env['dotykacka.order'].search(
            [('model_id', '=', pos_model_id), ('record_id', '=', self.id)]
        )
        return dotykacka_order

    def __send_to_dotykacka(self, request, branch_id, cloud_id, processed_data) -> bool:
        """
        Send prepared request to specific dotykacka branch.

        :param request: api_manager.request object
        :param branch_id: Identifier of dotykacka branch
        :param cloud_id: Identifier of dotykacka cloud

        :return: bool True if request was successful, False otherwise
        """
        if not self.env['dotykacka.base'].ping_pos_hw(cloud_id, branch_id):
            return False
        request.send_request_dotykacka(
            params={"{cloud_id}": cloud_id, "{branch_id}": branch_id},
            data=processed_data,
            return_type='status_code',
        )
        if not request.response.status_code != 200:
            return False
        return True

    def _ui_send_to_dotykacka(self) -> bool:
        """Send already processed order to dotykacka."""
        self.ensure_one()
        if not self.__check_terminal_dotykacka():
            return False

        request, branch_id, cloud_id = self.__prepare_dotykacka_request()
        dotykacka_order = self.__get_dotykacka_order()
        processed_data = self.__prepare_existing_dotykacka_data()
        self.write({'dotykacka_order_id': dotykacka_order.id})
        self.env.cr.commit()  # pylint:disable=E8102
        try:
            return self.__send_to_dotykacka(request, branch_id, cloud_id, processed_data)
        except Exception:  # pylint:disable=W0703
            return False

    def _pos_send_to_dotykacka(self, order_data) -> bool:
        """
        Send order from PoS to dotykacka.

        :param order_data: order data from PoS

        :return: True if order was sent to dotykacka, False otherwise
        """
        self.ensure_one()
        if not self.__check_terminal_dotykacka():
            return False

        request, branch_id, cloud_id = self.__prepare_dotykacka_request()
        dotykacka_order = self.__create_dotykacka_order(branch_id, cloud_id)

        processed_data = self.__prepare_new_dotykacka_data(order_data)
        self.write({'dotykacka_order_id': dotykacka_order.id})
        self.env.cr.commit()  # pylint:disable=E8102
        try:
            return self.__send_to_dotykacka(request, branch_id, cloud_id, processed_data)
        except Exception:  # pylint:disable=W0703
            return False

    @api.model
    def _process_order(self, order, draft: bool, existing_order):  # pylint:disable=R0914
        """
        Override :class:`PosOrder` :func:`_process_order`.

        Custom processes for Dotykacka Terminal:
        """
        res = super(PosOrder, self)._process_order(order, draft, existing_order)
        self.env.cr.commit()  # pylint:disable=E8102
        self.browse(res)._pos_send_to_dotykacka(order['data'])
        return res

    def print_receipt(self) -> dict:
        """
        Send existing order to dotykacka.

        :raise ValidationError: If order was already printed or sent to dotykacka
        :return: Action to reload page
        """
        if self.printed:
            msg = (
                "Cannot print receipt due to existing receipt!\n"
                "Please contact your support service!"
            )
            raise ValidationError(msg)
        if self.dotykacka_order_id and self.dotykacka_order_id.state != 'new':
            msg = (
                "Cannot print receipt due to existing record in Dotykacka!\n"
                "Please contact your support service!"
            )
            raise ValidationError(msg)
        if not self.dotykacka_order_id:
            msg = (
                "Cannot print receipt due to missing existing record of first attempt!\n"
                "Please contact your support service!"
            )
            raise ValidationError(msg)

        self._ui_send_to_dotykacka()
        return {
            'type': 'ir.actions.client',
            'tag': 'reload',
        }

    def add_dotykacka_payment(self, method_id: str = False):
        """
        Generate and confirm payment.

        If method ID is not provided, use same payment method as in parent order else get payment
        method based on dotykacka_method_identifier.

        :param method_id: string representing dotykacka_method_identifier
        """
        self.ensure_one()
        if method_id:
            payment_method = self.env['pos.payment.method'].search(
                [
                    ('company_id', '=', self.company_id.id),
                    ('dotykacka_method_identifier', '=', method_id),
                ]
            )
        elif not self.parent_id:
            payment_method = self.parent_id.payment_method
        else:
            return
        self.add_payment(
            {
                'payment_method_id': payment_method.id,
                'pos_order_id': self.id,
                'amount': self.amount_total,
            }
        )

    def refund(self):
        """Override refund on pos.order to extract refund_single method."""
        refund_orders = self.env['pos.order']
        for order in self:
            refund_orders |= order.refund_single()
        return {
            'name': _('Return Products'),
            'view_mode': 'form',
            'res_model': 'pos.order',
            'res_id': refund_orders.ids[0],
            'view_id': False,
            'context': self.env.context,
            'type': 'ir.actions.act_window',
            'target': 'current',
        }

    def action_view_refunds(self) -> dict:
        """
        Show refund orders on pos.order.

        This function returns an action that display existing refund orders
        of given pos order ids. It can either be a in a list or in a form
        view, if there is only one refund order to show.

        :return: View definition.
        """
        action = self.env.ref('point_of_sale.action_pos_pos_form').read()[0]
        refunds = self.mapped('return_ids')
        if len(refunds) > 1:
            action['domain'] = [('id', 'in', refunds.ids)]
        elif refunds:
            form_view = [(self.env.ref('point_of_sale.view_pos_pos_form').id, 'form')]
            if 'views' in action:
                action['views'] = form_view + [
                    (state, view) for state, view in action['views'] if view != 'form'
                ]
            else:
                action['views'] = form_view
            action['res_id'] = refunds.ids[0]

        # Prepare the context.
        action['context'] = dict(
            self._context, default_partner_id=self.partner_id.id, default_origin=self.name
        )
        return action

    def refund_dotykacka(self):
        """Create refund order triggered by dotykacka."""
        self.ensure_one()
        pos_config = self.session_id.config_id
        session_user = pos_config.current_user_id
        if not session_user:
            err_msg = (
                "To return product(s), you need to open a session in the POS "
                f"{pos_config.display_name}"
            )
            raise ValidationError(_(err_msg))

        session = pos_config.session_ids.filtered(
            lambda s: (s.user_id.id == session_user.id and not s.state == 'closed' and not s.rescue)
        )
        return self.sudo().refund_single(session and session[0] or False)

    def _get_current_session(self):
        """
        Get related config current session.

        When a refund is performed, we are creating it in a session having the same config as the
        original order. It can be the same session, or if it has been closed the new one that has
        been opened.

        :param err_msg: Return UserError with message when provided
        :raise UserError: if
        """
        current_session = self.session_id.config_id.current_session_id
        if not current_session:
            err_msg = (
                "To return product(s), you need to open a session in the POS "
                f"{self.session_id.config_id.display_name}"
            )
            raise UserError(_(err_msg))
        return current_session

    def refund_single(self, current_session=None):
        """Override 'refund' to map parent and child record."""
        self.ensure_one()
        if not current_session:
            current_session = self._get_current_session()
        refund_order = self.copy(
            {
                'name': self.name + _(' REFUND'),
                'session_id': current_session.id,
                'date_order': fields.Datetime.now(),
                'pos_reference': self.pos_reference,
                'lines': False,
                'amount_tax': -self.amount_tax,
                'amount_total': -self.amount_total,
                'amount_paid': 0,
                'parent_id': self.id,
            }
        )
        for line in self.lines:
            lot_env = self.env['pos.pack.operation.lot']
            for pack_lot in line.pack_lot_ids:
                lot_env += pack_lot.copy()
            neg_qty = -line.qty
            neg_untaxed_subtotal = -line.price_subtotal
            neg_taxed_subtotal = -line.price_subtotal_incl
            line.copy(
                {
                    'name': line.name + _(' REFUND'),
                    'qty': neg_qty,
                    'order_id': refund_order.id,
                    'price_subtotal': neg_untaxed_subtotal,
                    'price_subtotal_incl': neg_taxed_subtotal,
                    'pack_lot_ids': lot_env,
                }
            )
        self.write({'return_ids': [(4, refund_order.id)]})
        return refund_order
